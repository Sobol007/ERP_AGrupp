
#Область ЗапускОбработчиков

//Процедура - Запустить обработчкики
//
Процедура ЗапуститьОбработчики() Экспорт
	
	Если Не сшпФункциональныеОпции.ИспользоватьСШП() Тогда 
		
		Возврат;
		
	КонецЕсли;
	
	ИмяСобытияЖР = "Datareon.Инициация подключения к адаптеру";
	
	ЗаписьЖурналаРегистрации(ИмяСобытияЖР, УровеньЖурналаРегистрации.Информация,,, ИмяСобытияЖР);
	
	Если Не сшпОбщегоНазначения.ПроверитьЭкземплярИнформационнойБазы() Тогда
		
		ЗаписьЖурналаРегистрации(ИмяСобытияЖР, УровеньЖурналаРегистрации.Ошибка,,, "Рассинхронизация идентификаторов информационной базы");
		Возврат;
		
	КонецЕсли;
	
	ДанныеСтрокиСоединения = СтрРазделить(СтрокаСоединенияИнформационнойБазы(), ";");
	
	Если Не ДанныеСтрокиСоединения.Количество()=3 Тогда
		
		ЗаписьЖурналаРегистрации(ИмяСобытияЖР, УровеньЖурналаРегистрации.Ошибка, ,,"Работа с файловыми информационными базами не поддерживается",);
		Возврат;
		
	КонецЕсли;
	
	ИмяБазы = Сред(ДанныеСтрокиСоединения[1], 6, СтрДлина(ДанныеСтрокиСоединения[1])-6);
	ПозицияРазделителя = СтрНайти(ДанныеСтрокиСоединения[0], ":");
	
	Если ПозицияРазделителя = 0 Тогда
		
		НомерПорта = 1541;
		
	Иначе
		
		НомерПорта = Число(Сред(ДанныеСтрокиСоединения[0], ПозицияРазделителя+1, СтрДлина(ДанныеСтрокиСоединения[0])-ПозицияРазделителя-1));
		
	КонецЕсли;
	
	ИДАдаптера = "";
	ИмяАдаптера = "";
	
	Компонента = сшпКэшируемыеФункции.ПолучитьКомпоненту();
	
	Если Компонента = Неопределено Тогда
		
		Возврат;
		
	КонецЕсли;
	
	СостояниеАдаптера = Компонента.GetAdapterState(НомерПорта, ИмяБазы, ИДАдаптера, ИмяАдаптера);
	
	Компонента.Stop();
	
	Если СостояниеАдаптера = 0 Тогда
		
		сшпОбщегоНазначения.УстановитьСвойстваАдаптераPipe(ИДАдаптера, ИмяАдаптера);
		
		ЗапуститьПоток("сшпPipe.ПолучениеСлужебныхСообщений", "сшпPipe.ПолучениеСлужебныхСообщений", );
		ЗапуститьПоток("сшпОбслуживаниеОчередей.ОчисткаОчередейСообщений", "сшпОбслуживаниеОчередей.ОчисткаОчередейСообщений");
		
		ЗапуститьПотокОбменаТранспортнымиСообщениями();
		
	ИначеЕсли Не сшпФункциональныеОпции.ТипИспользуемогоКоннектораESB() = Перечисления.сшпТипыКоннекторовESB.Pipe Тогда 
	
		Возврат;
	
	ИначеЕсли (СостояниеАдаптера = 1) Тогда
		
		ТекстСообщения = "Не обнаружен адаптер для работы с текущей ИБ. Проверьте настройки адаптера. Имя базы = " + ИмяБазы + "; номер порта = " + НомерПорта;
		ЗарегистрироватьРезультатЗавершенияЗадания(ИмяСобытияЖР, УровеньЖурналаРегистрации.Предупреждение, ТекстСообщения);
		
	ИначеЕсли (СостояниеАдаптера = 2) Тогда
		
		ТекстСообщения = "Адаптер " + ИмяАдаптера + " остановлен. Передача данных остановлена.";
		ЗарегистрироватьРезультатЗавершенияЗадания(ИмяСобытияЖР, УровеньЖурналаРегистрации.Информация, ТекстСообщения);
		
	ИначеЕсли (СостояниеАдаптера = 3) Тогда
		
		ТекстСообщения = "Не обнаружен менеджер узла. Проверьте состояние сервиса Datareon на сервере 1С";
		ЗарегистрироватьРезультатЗавершенияЗадания(ИмяСобытияЖР, УровеньЖурналаРегистрации.Ошибка, ТекстСообщения);
		
	Иначе
		
		ТекстСообщения = "Не удалось инициализировать подключение к адаптеру. Получено неизвестное состояние адаптера " + СостояниеАдаптера + ". Получено Id адаптера = " + ИДАдаптера + "; имя адаптера = " + ИмяАдаптера;
		ЗарегистрироватьРезультатЗавершенияЗадания(ИмяСобытияЖР, УровеньЖурналаРегистрации.Ошибка, ТекстСообщения);
		
	КонецЕсли;  
	
КонецПроцедуры

//Процедура - Зарегистрировать результат завершения задания
//
//Параметры:
//	ИмяСобытияЖР - Строка - Имя события
//	Уровень - УровеньЖурналаРегистрации - Уровень важности события
//	ТекстСообщения - Строка - Произвольная строка комментария по событию
//
Процедура ЗарегистрироватьРезультатЗавершенияЗадания(ИмяСобытияЖР, Уровень, ТекстСообщения)
	            
	ЗаписьЖурналаРегистрации(ИмяСобытияЖР, Уровень,,, ТекстСообщения);
	
	Сообщение = Новый СообщениеПользователю();
	Сообщение.Текст = ТекстСообщения;
	Сообщение.Сообщить();
	
КонецПроцедуры

//Процедура - Запустить поток обмена транспортными сообщениями
//
Процедура ЗапуститьПотокОбменаТранспортнымиСообщениями()
	
	Если Не сшпФункциональныеОпции.ОтключитьПотоки() Тогда
		
		//Входящий поток
		максимумПотоков = сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпМаксимальноеКоличествоПотоковОбработкиВходящих");
		МассивПараметров = Новый Массив;
		МассивПараметров.Добавить();
		
		Для Индекс = 1 По МаксимумПотоков Цикл
			
			МассивПараметров[0] = Индекс;
			ЗапуститьПоток("сшпPipe.ПолучениеТранспортныхСообщений_" + Формат(Индекс, "ЧН=0; ЧГ=0"), "сшпPipe.ПолучениеТранспортныхСообщений", МассивПараметров);
			
		КонецЦикла;
		
		//Исходящий поток
		ЗапуститьПоток("сшпPipe.ОбработкаОчередиИсходящихСообщений", "сшпPipe.ОбработкаОчередиИсходящихСообщений",);
		
		МаксимумПотоков = сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпМаксимальноеКоличествоПотоковОбработкиИсходящих");
		МассивПараметров = Новый Массив;
		МассивПараметров.Добавить();
		
		Для Индекс = 1 По МаксимумПотоков Цикл
			
			МассивПараметров[0] = Индекс;
			ЗапуститьПоток("сшпPipe.ПередачаТранспортныхСообщений_" + Формат(Индекс, "ЧН=0; ЧГ=0"), "сшпPipe.ПередачаТранспортныхСообщений", МассивПараметров);
			
		КонецЦикла;
		
	КонецЕсли;

	//ПолучениеКвитанций
	ЗапуститьПоток("сшпPipe.ПолучениеКвитанций", "сшпPipe.ПолучениеКвитанций",);
	
КонецПроцедуры

//Процедура - запускает поток с ожиданием, который после паузы запускает указанный в параметрах поток
//
//Параметры:
//	ИмяМетода - строка - имя вызываемого метода
//	ПутьКМетоду - строка - имя процедуры
//	Параметры - массив - массив параметров
//	Пауза - число - количество секунд ожидания перед запуском
//
Процедура ЗапуститьПотокСЗадержкойАссинхронно(ИмяМетода, ПутьКМетоду, Параметры = Неопределено, Пауза = 1) Экспорт
	
	МассивПараметров = Новый Массив;
	МассивПараметров.Добавить(ИмяМетода);
	МассивПараметров.Добавить(ПутьКМетоду);
	МассивПараметров.Добавить(Параметры);
	МассивПараметров.Добавить(Пауза);
	
	ФоновыеЗадания.Выполнить("сшпPipe.ЗапуститьПотокСЗадержкой", массивПараметров, , "сшпPipe.ЗапуститьПотокСЗадержкой: " + ИмяМетода);
	
КонецПроцедуры

//Процедура - запускает поток с ожиданием
//
//Параметры:
//	ИмяМетода - строка - имя вызываемого метода
//	ПутьКМетоду - строка - имя процедуры
//	Параметры - массив - массив параметров
//	Пауза - число - количество секунд ожидания перед запуском
//
Процедура ЗапуститьПотокСЗадержкой(ИмяМетода, ПутьКМетоду, Параметры = Неопределено, Пауза = 1) Экспорт
	
	сшпОбщегоНазначения.Ожидание(Пауза);
	
	ЗапуститьПоток(ИмяМетода, ПутьКМетоду, Параметры);
	
КонецПроцедуры

//Процедура - запускает поток
//
//Параметры:
//	ИмяМетода - строка - имя вызываемого метода
//	ПутьКМетоду - строка - имя процедуры
//	Параметры - массив - массив параметров
//
Процедура ЗапуститьПоток(ИмяМетода, ПутьКМетоду, Параметры = Неопределено) Экспорт
	
	Попытка
		
		ФоновыеЗадания.Выполнить(ПутьКМетоду, Параметры, ИмяМетода, ИмяМетода );
		
	Исключение
		
		// Запускаем фоновое задание со статическим ключем. Запуск других экземпляров должен заканчиваться ошибкой (паттерн синглтон).
		
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

#Область СервисныйПоток

//Процедура - Получение служебных сообщений
//
Процедура ПолучениеСлужебныхСообщений() Экспорт
	
	ВходящаяОчередь = сшпКэшируемыеФункции.ПолучитьКомпоненту();
	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	ИмяКаналаВходящаяОчередь = ИдАдаптера + "_out_0";
	ИмяКаналаИсходящаяОчередь = ИдАдаптера + "_ack_0";
	
	Попытка
		
		ВходящаяОчередь.InitServicePipe(ИмяКаналаВходящаяОчередь, ИмяКаналаИсходящаяОчередь);
		
	Исключение
		
		ТекстОшибки = "При инициализации сервисного канала """ + ИмяКаналаВходящаяОчередь + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗапуститьПотокСЗадержкойАссинхронно("сшпPipe.ПолучениеСлужебныхСообщений", "сшпPipe.ПолучениеСлужебныхСообщений");
		сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди системных сообщений", ТекстОшибки);
		
		Возврат;
		
	КонецПопытки;
	
	ФорматПакета = сшпКэшируемыеФункции.ФорматСообщенийПоУмолчанию();
	ВерсияПараметровПодсистемы = сшпФункциональныеОпции.ВерсияПараметровПодсистемы();
	
	Пока Истина Цикл
		
		Если Не ПроверитьРазрешениеНаРаботу(ВерсияПараметровПодсистемы, Перечисления.сшпТипыОчередей.Системная, 0) Тогда
			
			Прервать;
			
		КонецЕсли;
		
		Попытка
			
			СообщениеПолучено = ВходящаяОчередь.GetNewMessage(1000);
			
		Исключение
			
			ТекстОшибки = "При получении сообщения из канала """ + ИмяКаналаВходящаяОчередь + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ЗапуститьПотокСЗадержкойАссинхронно("сшпPipe.ПолучениеСлужебныхСообщений", "сшпPipe.ПолучениеСлужебныхСообщений");
			сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди системных сообщений", ТекстОшибки);
			
			Прервать;
			
		КонецПопытки;
		
		Если Не СообщениеПолучено Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		ТипСообщения = ВходящаяОчередь.GetType();
		Идентификатор = ВходящаяОчередь.GetMessageId();
		КлассСообщения = ВходящаяОчередь.GetClassID();
		ТелоПакета = ВходящаяОчередь.GetMessage();
		
		Попытка
						
			//ТипСообщения = "CSM": не используется в текущем протоколе
			//ТипСообщения = "GPS": не используется в текущем протоколе
			Если КлассСообщения = "CSA" Тогда
				
				сткПараметры = сшпОбщегоНазначения.ПолучитьПараметрыСообщенияСтруктуройПоПакетуXML(ТелоПакета);
				
				Если сшпРаботаСДанными.УстановитьПараметрыАдаптера(сткПараметры) Тогда
					
					//изменились параметры, нужно выполнить перезапуск сеансов
					ЗапуститьПотокСЗадержкойАссинхронно("сшпPipe.НачатьОбмен", "сшпPipe.НачатьОбмен", 10);
					
				КонецЕсли;
				
			ИначеЕсли КлассСообщения = "GCM" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(Идентификатор);
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпОбслуживаниеОчередей.ВыполнитьВнешнююКоманду", мсвПараметры);
				
			ИначеЕсли ТипСообщения = "SUS" Тогда
				
				сткПараметры = сшпОбщегоНазначения.ПолучитьПараметрыСообщенияСтруктуройПоПакетуXML(ТелоПакета);
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(Идентификатор);
				мсвПараметры.Добавить(сткПараметры);
				
				ФоновыеЗадания.Выполнить("сшпОбслуживаниеОчередей.УстановитьПараметрыПользователя", мсвПараметры);
				
			ИначеЕсли КлассСообщения = "TUM" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ОбновитьОбработчикСобытия", мсвПараметры, Идентификатор, "ОбновитьОбработчикСобытия. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "TCS" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.УправлениеСостояниемОбработчика", мсвПараметры, Идентификатор, "УправлениеСостояниемОбработчика. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "TRM" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.УдалитьОбработчикСобытия", мсвПараметры, Идентификатор, "УдалитьОбработчикСобытия. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "TLR" Тогда
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ПолучитьСписокВерсийОбработчиковСобытий",, Идентификатор, "ПолучитьСписокВерсийОбработчиковСобытий. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "TSR" Тогда
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ПолучитьСписокОбработчиковСобытий",, Идентификатор, "ПолучитьСписокОбработчиковСобытий. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "RML" Тогда
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ВозвратПакетовВОбработку", мсвПараметры, Идентификатор, "ВозвратПакетовВОбработку. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "BMR" Тогда
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.ПолучитьСтруктуруКонфигурации",, Идентификатор, "ПолучитьСтруктуруКонфигурации");
				
			ИначеЕсли КлассСообщения = "V1C" Тогда
				
				сшпСистемныеСообщения.ПолучитьВерсиюПодсистемы1С();
				
			ИначеЕсли КлассСообщения = "CSB" Тогда
				
				сшпСистемныеСообщения.ПолучитьПараметрыПодключения();
				
			ИначеЕсли КлассСообщения = "FND" Тогда    
				
				мсвПараметры = Новый Массив;
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				мсвПараметры.Добавить(Идентификатор);
				
				ФоновыеЗадания.Выполнить("сшпСистемныеСообщения.НайтиСообщения", мсвПараметры, Идентификатор, "НайтиСообщения. id = " + Идентификатор);
				
			ИначеЕсли КлассСообщения = "DEB" Тогда
				
				мсвПараметры = Новый Массив;   
				мсвПараметры.Добавить(ФорматПакета);
				мсвПараметры.Добавить(ТелоПакета);
				мсвПараметры.Добавить(Идентификатор);
				
				ФоновыеЗадания.Выполнить("сшпОтладкаОбработчиков.ВыполнитьОтладкуОбработчика", мсвПараметры, Идентификатор, "ВыполнитьОтладкуОбработчика. id = " + Идентификатор);
				
			Иначе
				
				ТекстОшибки = "В сервисном канале получено сообщение неизвестного класса/типа " + КлассСообщения + "/" + ТипСообщения + ". Сообщение не будет обработано. id = " + Идентификатор;
				
				Если ТипСообщения = "TrackMessage" Тогда
					
					ВходящаяОчередь.SendAckMessage(Идентификатор, 2, ТекстОшибки);
				
				Иначе			
				
					сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди системных сообщений", ТекстОшибки);
				
				КонецЕсли;
				
			КонецЕсли;
			
		Исключение
			
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди системных сообщений", ТекстОшибки);
			
		КонецПопытки;
		
	КонецЦикла;
	
	ВходящаяОчередь.Stop();
	
КонецПроцедуры

//Процедура - Установить соединение и отправить служебное сообщение
//
//Параметры:
//	XDTOПакет - Структура - содержит поля соответствующие описанию формата объекта Message1C
//
Процедура УстановитьСоединениеИОтправитьСлужебноеСообщение(XDTOПакет) Экспорт
	
	Очередь = сшпКэшируемыеФункции.ПолучитьКомпоненту("service");
	
	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	Очередь.InitDataSender(ИдАдаптера + "_datareon_server");
	
	xmlПакет = сшпОбщегоНазначения.СформироватьСообщениеESB_HTTP(ФабрикаXDTO, XDTOПакет);
	
	ОтправитьСообщение(Очередь, xmlПакет);
	
	Очередь.Stop();
	
КонецПроцедуры	

#КонецОбласти

#Область ВходящийПоток

//Функция - обрабатывает входящее сообщение
//
//Параметры:
//	Идентификатор - Строка - идентификатор передаваемого сообщения
//	КлассСообщения - Строка - класс сообщения
//	ОбъектСобытия - Структура - структура загружаемого пакета
//	СткОбработчик - Фиксированная структура - структура обработчика для входящего сообщения
//	ФорматСообщения - Перечисление.сшпФорматыСообщений - формат входящего сообщения
//	Задержка - Число - Количество секунд задержки перед обработкой
//	ТекстОшибки - Строка - возвращаемый текст ошибки
//	ДатаРегистрации - Дата - Дата/время регистрации сообщения в очереди
//
//Возвращаемое значение:
//	Перечисление.сшпСтатусыСообщений - статус сообщения после обработки
//
Функция ВыполнитьОбработкуВходящегоСообщения(Знач Идентификатор, Знач КлассСообщения, ОбъектСобытия, СткОбработчик, Знач ФорматСообщения, Задержка, ТекстОшибки, ДатаРегистрации);
	
	идШаблона = сткОбработчик.ИдентификаторШаблона;
	версияШаблона = сткОбработчик.Версия;
	СостояниеСообщения = Перечисления.сшпСтатусыСообщений.Обработано;
		
	Попытка
				
		ОбъектСообщение = сшпОбщегоНазначения.ПолучитьОбъектXDTO(ФорматСообщения, объектсобытия);
				
	Исключение
		
		//Сообщение не валидно
		ТекстОшибки = "Не удалось десериализовать сообщение " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		СостояниеСообщения = Перечисления.сшпСтатусыСообщений.НеВалидно;
		
	КонецПопытки;
		
	Если СостояниеСообщения = Перечисления.сшпСтатусыСообщений.Обработано Тогда
		
		Попытка
			
			Выполнить (сткОбработчик.ПроцедураОбработки);
			
		Исключение
			
			ТекстОшибки = сшпОбщегоНазначения.ПолучитьТекстОшибкиОбработчика(ИнформацияОбОшибке());
				
			СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки;
			
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат СостояниеСообщения;
	
КонецФункции

//Процедура - Получение транспортных сообщений
//
//Параметры:
//	ИндексПотока - Число - индекс запускаемого потока
//
Процедура ПолучениеТранспортныхСообщений(ИндексПотока) Экспорт
	
	ТекстОшибки = "";
	АварийноеЗавершение = Ложь;
	
	ВходящаяОчередь = сшпКэшируемыеФункции.ПолучитьКомпоненту();
	ИсходящаяОчередь = сшпКэшируемыеФункции.ПолучитьКомпоненту("service");
	
	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	ИмяКаналаВходящаяОчередь = ИдАдаптера + "_out_" + Формат(ИндексПотока, "ЧН=0; ЧГ=0;");
	
	Попытка
		
		ВходящаяОчередь.InitDataReceiver(ИмяКаналаВходящаяОчередь, 
		ИдАдаптера + "_ack_" + Формат(ИндексПотока, "ЧН=0; ЧГ=0;"));
		
	Исключение
		
		ТекстОшибки = "При инициализации транспортного канала для получения сообщений """ + ИмяКаналаВходящаяОчередь + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());		
		сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди входящих сообщений", ТекстОшибки);
		
		//возможно проблема на стороне адаптера, инициализация выполнится повторно регламентным заданием
		ВызватьИсключение ТекстОшибки;
		
	КонецПопытки;
	
	Попытка
		
		ИсходящаяОчередь.InitDataSender(ИдАдаптера + "_datareon_server");
		
	Исключение
		
		ТекстОшибки = "При инициализации сервисного канала для отправки сообщений """ + ИмяКаналаВходящаяОчередь + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());		
		ЗаписьЖурналаРегистрации("Datareon. Обработка очереди входящих сообщений", УровеньЖурналаРегистрации.Ошибка,,, ТекстОшибки);
		
		ВходящаяОчередь.Stop();
		
		//возможно проблема на стороне адаптера, инициализация выполнится повторно регламентным заданием
		ВызватьИсключение ТекстОшибки;
		
	КонецПопытки;
	
	ФорматПакета = сшпКэшируемыеФункции.ФорматСообщенийПоУмолчанию();
	ВерсияПараметровПодсистемы = сшпФункциональныеОпции.ВерсияПараметровПодсистемы();
		
	Пока Истина Цикл
		
		Если Не ПроверитьРазрешениеНаРаботу(ВерсияПараметровПодсистемы, Перечисления.сшпТипыОчередей.Входящая, ИндексПотока) Тогда
			
			Прервать;
			
		КонецЕсли;
				
		Попытка
			
			СообщениеПолучено = ВходящаяОчередь.GetNewMessage(1000);
			
		Исключение
			
			ТекстОшибки = "При получении сообщения из канала """ + ИмяКаналаВходящаяОчередь + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			
			ЗапуститьПотокСЗадержкойАссинхронно("сшпPipe.ЗапуститьПотокОбменаТранспортнымиСообщениями", "сшпPipe.ЗапуститьПотокОбменаТранспортнымиСообщениями");
			
			сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди системных сообщений", ТекстОшибки);
			
			АварийноеЗавершение = Истина;
			Прервать;
			
		КонецПопытки;
				
		Если Не СообщениеПолучено Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		ТипСообщения = ВходящаяОчередь.GetType();
		Идентификатор = ВходящаяОчередь.GetMessageId();
		КлассСообщения = ВходящаяОчередь.GetClassID();
				
		СткОбработчик = сшпКэшируемыеФункции.ПолучитьОбработчик(КлассСообщения, Перечисления.сшпТипыИнтеграции.Входящая, сшпФункциональныеОпции.ВерсияОбработчиков());
				
		Если Не СткОбработчик.ОбработчикНайден Тогда
			
			ПотвердитьОбработкуВходящегоСообщения(Идентификатор, ВходящаяОчередь, Перечисления.сшпСтатусыСообщений.ОтсутствуетОбработчик,, 
			"Отсутствует обработчик для класса " + КлассСообщения);
			
			Продолжить;
			
		ИначеЕсли СткОбработчик.Отлючен Тогда
			
			ПотвердитьОбработкуВходящегоСообщения(Идентификатор, ВходящаяОчередь, Перечисления.сшпСтатусыСообщений.ОбработкаОтменена, ,
			"Обработчик для класса " + КлассСообщения + " найден, но отключен.");
			
			Продолжить;
			
		КонецЕсли;
			
		ОбъектСобытия = ВходящаяОчередь.GetMessage();
				
		ТекстОшибкиОбработкиСообщения = "";
		Задержка = 0;
				
		ДатаРегистрации = МестноеВремя(ВходящаяОчередь.GetCreationTime(), ЧасовойПояс());
		                     
		СостояниеСообщения = ВыполнитьОбработкуВходящегоСообщения(Идентификатор, КлассСообщения, ОбъектСобытия, сткОбработчик, форматПакета, Задержка, ТекстОшибкиОбработкиСообщения, ДатаРегистрации);
				
		ПотвердитьОбработкуВходящегоСообщения(Идентификатор, ВходящаяОчередь, СостояниеСообщения, Задержка, ТекстОшибкиОбработкиСообщения);
		
		Если СостояниеСообщения = Перечисления.сшпСтатусыСообщений.НеВалидно Тогда 
			
			ЗаписьЖурналаРегистрации("Datareon. Обработка сообщения", УровеньЖурналаРегистрации.Ошибка, , Идентификатор, ТекстОшибкиОбработкиСообщения);
			
		ИначеЕсли СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки Тогда
			
			ЗаписьЖурналаРегистрации("Datareon. Обработка сообщения", УровеньЖурналаРегистрации.Ошибка, , Идентификатор, ТекстОшибкиОбработкиСообщения);
			
			сткСвойства = Новый Структура;
			сткСвойства.Вставить("TemplateId", Строка(сткОбработчик.ИдентификаторШаблона));
			сткСвойства.Вставить("TemplateVersion", сткОбработчик.Версия);
			сткСвойства.Вставить("MessageId", Строка(Идентификатор));
			сткСвойства.Вставить("TemplateName", сткОбработчик.Наименование);
			
			ТекстОшибки = ОтправитьСообщениеОбОшибке(ИсходящаяОчередь, "Handler", ТекстОшибкиОбработкиСообщения, сткСвойства); 
						
			Если ЗначениеЗаполнено(ТекстОшибки) Тогда
				
				ЗапуститьПотокСЗадержкойАссинхронно("сшпPipe.ЗапуститьПотокОбменаТранспортнымиСообщениями", "сшпPipe.ЗапуститьПотокОбменаТранспортнымиСообщениями");
				
				АварийноеЗавершение = Истина;
				Прервать;
				
			КонецЕсли;
			
		КонецЕсли;
				
	КонецЦикла;
	
	ВходящаяОчередь.Stop();
	ИсходящаяОчередь.Stop();
	
	Если АварийноеЗавершение Тогда
		
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры

//Процедура - Подтверждает обработку входящего сообщения
//
//Параметры:
//	Идентификатор - Строка - идентификатор сообщения
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты обработки очереди
//	Состояние - Перечисление.сшпСтатусыСообщений - состояние сообщения
//	Задержка - Число - количество секунд обработки сообщения
//	ТекстОшибки - Строка - возвращаемый текст ошибки
//
Процедура ПотвердитьОбработкуВходящегоСообщения(Идентификатор, Очередь, Состояние, Задержка = 0, ТекстОшибки) 
	
	КодСостояния = сшпКэшируемыеФункции.ПолучитьКодСостоянияОбработки(Состояние);
	
	Если КодСостояния = -1 Тогда
		
		Очередь.PostponeMessage(Идентификатор, Задержка*1000);
		
	Иначе
		
		Очередь.SendAckMessage(Идентификатор, КодСостояния, ТекстОшибки);
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти


#Область ИсходящийПоток

//Процедура - обработка очереди исходящих сообщения
//
Процедура ОбработкаОчередиИсходящихСообщений() Экспорт 

	КоличествоСообщенийБуфера = 50;
	ДлительностьОжиданияКвитанций = 600; //в секундах
	КоличествоПотоков = сшпРаботаСКонстантами.МаксимальноеКоличествоПотоковОбработкиИсходящих();
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ ПЕРВЫЕ " + Формат(КоличествоПотоков*КоличествоСообщенийБуфера, "ЧГ=0") + "
		|	сшпСостояниеСообщений.ИндексПотока КАК ИндексПотока,
		|	сшпСостояниеСообщений.СтатусСообщения КАК СтатусСообщения,
		|	сшпОчередьИсходящихСообщений.ИдентификаторСообщения КАК ИдентификаторСообщения,
		|	ВЫБОР
		|		КОГДА сшпСостояниеСообщений.СтатусСообщения = ЗНАЧЕНИЕ(Перечисление.сшпСтатусыСообщений.ВОбработке)
		|			ТОГДА 0
		|		ИНАЧЕ 1
		|	КОНЕЦ КАК Порядок
		|ПОМЕСТИТЬ кРаспределению
		|ИЗ
		|	РегистрСведений.сшпОчередьИсходящихСообщений КАК сшпОчередьИсходящихСообщений
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.сшпСостояниеСообщений КАК сшпСостояниеСообщений
		|		ПО сшпОчередьИсходящихСообщений.ИдентификаторСообщения = сшпСостояниеСообщений.ИдентификаторСообщения
		|ГДЕ
		|	сшпСостояниеСообщений.СтатусСообщения В(&СтатусСообщенияКАнализу)
		|	И сшпСостояниеСообщений.ЗадержкаЧисло <= &Задержка
		|
		|СГРУППИРОВАТЬ ПО
		|	сшпСостояниеСообщений.ИндексПотока,
		|	сшпСостояниеСообщений.СтатусСообщения,
		|	сшпОчередьИсходящихСообщений.ИдентификаторСообщения
		|
		|УПОРЯДОЧИТЬ ПО
		|	Порядок
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	кРаспределению.ИдентификаторСообщения КАК ИдентификаторСообщения
		|ИЗ
		|	кРаспределению КАК кРаспределению
		|ГДЕ
		|	кРаспределению.СтатусСообщения В(&СтатусСообщенияНераспределенные)
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	кРаспределению.ИндексПотока КАК ИндексПотока,
		|	СУММА(1) КАК Количество
		|ИЗ
		|	кРаспределению КАК кРаспределению
		|ГДЕ
		|	кРаспределению.ИндексПотока <> 0
		|
		|СГРУППИРОВАТЬ ПО
		|	кРаспределению.ИндексПотока
		|
		|УПОРЯДОЧИТЬ ПО
		|	ИндексПотока";
		
	СтатусСообщенияНераспределенные = сшпКэшируемыеФункции.ПоучитьСписокРабочихСтатусов();	
	СтатусСообщенияКАнализу = Новый Массив;
	
	Для Каждого ЭлементМассива Из СтатусСообщенияНераспределенные Цикл
		
		СтатусСообщенияКАнализу.Добавить(ЭлементМассива);
		
	КонецЦикла;
	
	СтатусСообщенияКАнализу.Добавить(Перечисления.сшпСтатусыСообщений.ВОбработке);
	
	Запрос.УстановитьПараметр("СтатусСообщенияКАнализу", СтатусСообщенияКАнализу);
	Запрос.УстановитьПараметр("СтатусСообщенияНераспределенные", СтатусСообщенияНераспределенные);
	
	ЗапросПоискЗависших = Новый Запрос;
	ЗапросПоискЗависших.Текст = 
		"ВЫБРАТЬ
		|	сшпОчередьИсходящихСообщений.ИдентификаторСообщения КАК Идентификатор
		|ИЗ
		|	РегистрСведений.сшпОчередьИсходящихСообщений КАК сшпОчередьИсходящихСообщений
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.сшпСостояниеСообщений КАК сшпСостояниеСообщений
		|		ПО сшпОчередьИсходящихСообщений.ИдентификаторСообщения = сшпСостояниеСообщений.ИдентификаторСообщения
		|ГДЕ
		|	сшпСостояниеСообщений.СтатусСообщения = ЗНАЧЕНИЕ(Перечисление.сшпСтатусыСообщений.ВОбработке)
		|	И (сшпСостояниеСообщений.ИндексПотока > &КоличествоПотоков
		|			ИЛИ сшпСостояниеСообщений.ИндексПотока = 0)
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	сшпОчередьИсходящихСообщений.ИдентификаторСообщения
		|ИЗ
		|	РегистрСведений.сшпОчередьИсходящихСообщений КАК сшпОчередьИсходящихСообщений
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.сшпСостояниеСообщений КАК сшпСостояниеСообщений
		|		ПО сшпОчередьИсходящихСообщений.ИдентификаторСообщения = сшпСостояниеСообщений.ИдентификаторСообщения
		|ГДЕ
		|	сшпСостояниеСообщений.СтатусСообщения = ЗНАЧЕНИЕ(Перечисление.сшпСтатусыСообщений.Отправлено)
		|	И сшпСостояниеСообщений.ДатаИзменения < &ДатаОтправки";	
	ЗапросПоискЗависших.УстановитьПараметр("КоличествоПотоков", КоличествоПотоков);
	
	Пока сшпФункциональныеОпции.ИспользоватьСШП() И Не сшпФункциональныеОпции.ОтключитьПотоки() Цикл 
		
		Запрос.УстановитьПараметр("Задержка", сшпОбщегоНазначения.ПеревестиДатуВЧисло(ТекущаяДатаСеанса()));
		
		РезультатЗапроса = Запрос.ВыполнитьПакет();
		//РезультатЗапроса[1]: идентификаторы нераспределенных сообщений
		//РезультатЗапроса[2]: количество сообщений, находящиеся сейчас в обработке по каждому потоку
		
		СделатьПаузу = Истина;
		
		Если Не РезультатЗапроса[1].Пустой() Тогда //есть сообщения к распределению
			
			СделатьПаузу = Ложь;
			
			ВыборкаИдентификаторов = РезультатЗапроса[1].Выбрать();
			ВыборкаПотоков = РезультатЗапроса[2].Выбрать();
			
			ИндексПотока = 0;
			
			КоличествоВПотоке = КоличествоСообщенийБуфера; //инициализируем первое значение, превышающее буфер для перехода на следующий поток
			
			Пока ВыборкаИдентификаторов.Следующий() Цикл
				
				Пока КоличествоСообщенийБуфера <= КоличествоВПотоке Цикл    //буфер потока переполнен, перейдем к следующему
					
					ИндексПотока = ИндексПотока + 1;
					
					Если ВыборкаПотоков.НайтиСледующий(ИндексПотока, "ИндексПотока") Тогда 
						
						КоличествоВПотоке = ВыборкаПотоков.Количество;
						
					Иначе
						
						КоличествоВПотоке = 0;
						
					КонецЕсли;
					
				КонецЦикла;
				
				текИдентификатор = ВыборкаИдентификаторов.ИдентификаторСообщения;
				сшпРаботаСДанными.УстановитьСостояниеСообщения(текИдентификатор, Перечисления.сшпСтатусыСообщений.ВОбработке,,, ИндексПотока);
				
				КоличествоВПотоке = КоличествоВПотоке + 1;
				
			КонецЦикла;
			
		КонецЕсли;		
		
		//возможно имеются зависшие сообщения, нужно проверить.
		ЗапросПоискЗависших.УстановитьПараметр("ДатаОтправки", ТекущаяДатаСеанса() - ДлительностьОжиданияКвитанций);
		РезультатПоискаЗависших = ЗапросПоискЗависших.Выполнить();
		
		Если Не РезультатПоискаЗависших.Пустой() Тогда
			
			СделатьПаузу = Ложь;
			
			ВыборкаДетальныеЗаписи = РезультатПоискаЗависших.Выбрать();
			
			Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
				
				сшпРаботаСДанными.УстановитьСостояниеСообщения(ВыборкаДетальныеЗаписи.Идентификатор, Перечисления.сшпСтатусыСообщений.ОжиданиеОбработки,,);
				
			КонецЦикла;
			
		КонецЕсли;
		
		Если СделатьПаузу Тогда
			
			сшпОбщегоНазначения.Ожидание(1);
			
		КонецЕсли;

	КонецЦикла;
	
КонецПроцедуры

//Процедура - Передача транспортных сообщений
//
//Параметры:
//	ИндексПотока - Число - индекс потока
// 
Процедура ПередачаТранспортныхСообщений(ИндексПотока) Экспорт 

	ИсходящаяОчередь = сшпКэшируемыеФункции.ПолучитьКомпоненту();
	
	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	Попытка
		
		ИсходящаяОчередь.InitDataSender(ИдАдаптера + "_datareon_server");
		
	Исключение
		
		ТекстОшибки = "При инициализации транспортного канала для передачи сообщений """ + ИдАдаптера + "_datareon_server" + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗаписьЖурналаРегистрации("Datareon. Обработка очереди исходящих сообщений", УровеньЖурналаРегистрации.Ошибка,,, ТекстОшибки);

		Возврат;
		
	КонецПопытки;
			
	ФорматСообщения = сшпКэшируемыеФункции.ФорматСообщенийПоУмолчанию();
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 50
	|	сшпСостояниеСообщений.СтатусСообщения КАК СтатусСообщения,
	|	сшпОчередьИсходящихСообщений.ИдентификаторСообщения КАК ИдентификаторСообщения,
	|	сшпОчередьИсходящихСообщений.Хранилище КАК Хранилище,
	|	сшпОчередьИсходящихСообщений.ДатаРегистрации КАК ДатаРегистрации,
	|	сшпОчередьИсходящихСообщений.ОбъектСобытия КАК ОбъектСобытия,
	|	сшпОчередьИсходящихСообщений.ФорматСообщения КАК ФорматСообщения,
	|	сшпОчередьИсходящихСообщений.МетодХранения КАК МетодХранения,
	|	сшпОчередьИсходящихСообщений.ЭтоУдаление КАК ЭтоУдаление
	|ИЗ
	|	РегистрСведений.сшпОчередьИсходящихСообщений КАК сшпОчередьИсходящихСообщений
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.сшпСостояниеСообщений КАК сшпСостояниеСообщений
	|		ПО сшпОчередьИсходящихСообщений.ИдентификаторСообщения = сшпСостояниеСообщений.ИдентификаторСообщения
	|ГДЕ
	|	сшпСостояниеСообщений.СтатусСообщения = ЗНАЧЕНИЕ(Перечисление.сшпСтатусыСообщений.ВОбработке)
	|	И сшпСостояниеСообщений.ИндексПотока = &ИндексПотока";
		
	СтатусСообщенияНераспределенные = сшпКэшируемыеФункции.ПоучитьСписокРабочихСтатусов();
	
	СтатусСообщенияКАнализу = сшпКэшируемыеФункции.ПоучитьСписокРабочихСтатусов();
	
	СтатусСообщенияКАнализу.Добавить(Перечисления.сшпСтатусыСообщений.ВОбработке);
		
	Запрос.УстановитьПараметр("ИндексПотока", ИндексПотока);
	ВерсияПараметровПодсистемы = сшпФункциональныеОпции.ВерсияПараметровПодсистемы();
		
	Пока Истина Цикл
				
		Если Не ПроверитьРазрешениеНаРаботу(ВерсияПараметровПодсистемы, Перечисления.сшпТипыОчередей.Исходящая, ИндексПотока) Тогда
			
			Прервать;
			
		КонецЕсли;
			
		РезультатЗапроса = Запрос.Выполнить();
			
		Если РезультатЗапроса.Пустой() Тогда //нечего обрабатывать
			
			сшпОбщегоНазначения.Ожидание(1);
			
		Иначе
						
			Выборка = РезультатЗапроса.Выбрать();
			
			Пока Выборка.Следующий() Цикл 
				
				Идентификатор = Выборка.ИдентификаторСообщения;
								
				сткОбработчик = сшпКэшируемыеФункции.ПолучитьОбработчик(Выборка.ОбъектСобытия, Перечисления.сшпТипыИнтеграции.Исходящая, сшпФункциональныеОпции.ВерсияОбработчиков());
								
				Если Не сткОбработчик.ОбработчикНайден Тогда
					
					сшпРаботаСДанными.УстановитьСостояниеСообщения(Идентификатор, Перечисления.сшпСтатусыСообщений.ОтсутствуетОбработчик);
					
				ИначеЕсли сткОбработчик.Отлючен тогда
					
					сшпРаботаСДанными.УстановитьСостояниеСообщения(Идентификатор, Перечисления.сшпСтатусыСообщений.ОбработкаОтменена);
					
				Иначе
					
					Задержка = 0;
					ТекстОшибки = "";
										
					Объектсобытия = Выборка.Хранилище.Получить();
					
					РезультатОбработки = сшпОбщегоНазначения.СформироватьСтруктуруПакета();
										
					СостояниеСообщения = СформироватьИсходящееСообщение(РезультатОбработки, Идентификатор, Выборка.ОбъектСобытия, Выборка.методхранения, Объектсобытия, Задержка, сткОбработчик, Выборка.ФорматСообщения, ТекстОшибки);
										
					Если СостояниеСообщения = Перечисления.сшпСтатусыСообщений.Обработано Тогда
												
						СостояниеСообщения = ОтправитьТранспортноеСообщение(ИсходящаяОчередь, РезультатОбработки); 
												
						Если СостояниеСообщения = Перечисления.сшпСтатусыСообщений.НеВалидно Тогда
							
							СостояниеСообщения = РезультатОбработки;
							
						ИначеЕсли СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки Тогда 
							
							ЗапуститьПотокСЗадержкойАссинхронно("сшпPipe.ЗапуститьПотокОбменаТранспортнымиСообщениями", "сшпPipe.ЗапуститьПотокОбменаТранспортнымиСообщениями");
														
							Прервать;
							
						КонецЕсли;

					ИначеЕсли СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки Тогда
						
						сткСвойства = Новый Структура;
						сткСвойства.Вставить("TemplateId", Строка(сткОбработчик.ИдентификаторШаблона));
						сткСвойства.Вставить("TemplateVersion", сткОбработчик.Версия);
						сткСвойства.Вставить("MessageId", Строка(Идентификатор));
						сткСвойства.Вставить("TemplateName", сткОбработчик.Наименование);
						
						РезультатОтправкиСообщения = ОтправитьСообщениеОбОшибке(ИсходящаяОчередь, "Handler", ТекстОшибки, сткСвойства); 
						Если РезультатОтправкиСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки Тогда 
														
							ЗапуститьПотокСЗадержкойАссинхронно("сшпPipe.ЗапуститьПотокОбменаТранспортнымиСообщениями", "сшпPipe.ЗапуститьПотокОбменаТранспортнымиСообщениями");
														
							Прервать;
							
						КонецЕсли;
						
					Иначе
						
						СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОжиданиеОбработки;
						Задержка = 30;
						
					КонецЕсли;
					
					сшпРаботаСДанными.УстановитьСостояниеСообщения(Идентификатор, СостояниеСообщения, Задержка, ТекстОшибки);
					
				КонецЕсли;
				
			КонецЦикла;
						
		КонецЕсли;
		
	КонецЦикла;
	
	ИсходящаяОчередь.Stop();
	
КонецПроцедуры

//Функция - сформировать исходящее сообщение
//
//Параметры:
//	РезультатОбработки - структура - структура пакета, который будет выгружен из 1С
//	Идентификатор - строка - идентификатор сообщения
//	ТипОбъекта - строка - полное имя метаданных, которые вызвали обработку события
//	МетодХранения - Перечисление.сшпМетодХранения - метод хранения объекта
//	ОбъектСобытия - ЛюбаяСсылка, Отбор, ОбъектXDTO - зарегистрированный к выгрузке объект
//	Задержка - число - Количество секунд задержки перед обработкой
//	СткОбработчик - фиксированная структура - структура обработчика для исходящего сообщения
//	ФорматСообщения - Перечисление.сшпФорматыСообщений - формат исходящего сообщения
//	ТекстОшибки - строка - возвращаемый текст ошибки
//
//Возвращаемое значение:
//	Перечисление.сшпСтатусыСообщений - статус сообщения после обработки
//
Функция СформироватьИсходящееСообщение(РезультатОбработки, Идентификатор, ТипОбъекта, МетодХранения, ОбъектСобытия, Задержка, СткОбработчик, ФорматСообщения, ТекстОшибки)
	
	РезультатОбработки = сшпОбщегоНазначения.СформироватьСтруктуруПакета();
	РезультатОбработки.Id = Идентификатор;
	
	СостояниеСообщения = Перечисления.сшпСтатусыСообщений.Обработано;
	
	Попытка
		
		ОбъектОбработки = Неопределено;
		
		Если МетодХранения = Перечисления.сшпМетодХранения.ПоСсылке Тогда
			
			Если ТипЗнч(ОбъектСобытия) = Тип("Отбор") Тогда
				
				ТипРегистра = сшпКэшируемыеФункции.ПолучитьТипОбъекта(ТипОбъекта);
				ИмяРегистра = сшпКэшируемыеФункции.ПолучитьИмяОбъекта(ТипОбъекта);
				
				Если ТипРегистра = "РегистрСведений" Тогда
					
					ОбъектОбработки = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();	
					
				ИначеЕсли ТипРегистра = "РегистрНакопления" Тогда
					
					ОбъектОбработки = РегистрыНакопления[ИмяРегистра].СоздатьНаборЗаписей();
					
				ИначеЕсли ТипРегистра = "РегистрБухгалтерии" Тогда
					
					ОбъектОбработки = РегистрыБухгалтерии[ИмяРегистра].СоздатьНаборЗаписей();
					
				ИначеЕсли ТипРегистра = "РегистрРасчета" Тогда
					
					ОбъектОбработки = РегистрыРасчета[ИмяРегистра].СоздатьНаборЗаписей();
					
				Иначе
					
					ВызватьИсключение "Тип: " + ТипРегистра + " не поддерживается текущей версией подсистемы ESB";
					
				КонецЕсли;
				
				Для Каждого ЭлементОтбор Из ОбъектСобытия Цикл
					ЗаполнитьЗначенияСвойств(ОбъектОбработки.Отбор[элементОтбор.Имя], ЭлементОтбор);
				КонецЦикла;
				
				ОбъектОбработки.Прочитать();
				
			Иначе
				
				ОбъектОбработки = ОбъектСобытия;
				
			КонецЕсли;
			
		Иначе	
			
			ОбъектОбработки = сшпОбщегоНазначения.ПолучитьОбъектXDTO(ФорматСообщения, ОбъектСобытия);
			
		КонецЕсли;
		
		Выполнить(сткОбработчик.ПроцедураОбработки);
		
	Исключение
		
		ТекстОшибки = сшпОбщегоНазначения.ПолучитьТекстОшибкиОбработчика(ИнформацияОбОшибке());
		
		СостояниеСообщения = Перечисления.сшпСтатусыСообщений.ОшибкаОбработки;
		
	КонецПопытки;
	
	Возврат СостояниеСообщения;
	
КонецФункции

//Процедура - Получение квитанции
//
Процедура ПолучениеКвитанций() Экспорт
	
	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	ВходящаяОчередьКвитанций = сшпКэшируемыеФункции.ПолучитьКомпоненту();
	
	Попытка
		
		ВходящаяОчередьКвитанций.InitDataSender(ИдАдаптера + "_1c_server");
		
	Исключение
		
		ТекстОшибки = "При инициализации сервисного канала для получения квитанций """ + ИдАдаптера + "_1c_server" + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());

		ЗапуститьПотокСЗадержкойАссинхронно("сшпPipe.ПолучениеКвитанций", "сшпPipe.ПолучениеКвитанций");
		сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди входящих сообщений", ТекстОшибки);
		
		Возврат;
		
	КонецПопытки;
	
	Пока сшпФункциональныеОпции.ИспользоватьСШП() Цикл 
		
		Идентификатор = "";
		ТекстСообщения = "";
		
		Попытка
			
			РезультатОбработки = ВходящаяОчередьКвитанций.GetMessageHandleResult(Идентификатор, ТекстСообщения);
			
		Исключение
			
			ТекстОшибки = "При получении сообщения из сервисного канала квитанций """ + ИдАдаптера + "_1c_server" + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			
			ЗапуститьПотокСЗадержкойАссинхронно("сшпPipe.ПолучениеКвитанций", "сшпPipe.ПолучениеКвитанций");
			сшпОбщегоНазначения.ЗарегистрироватьЗаписьВЖурнале(УровеньЖурналаРегистрации.Ошибка, "Datareon. Обработка очереди системных сообщений", ТекстОшибки);
			
			Прервать;
			
		КонецПопытки;
		
		Если (РезультатОбработки >= 0) Тогда
			
			СостояниеСообщения = сшпКэшируемыеФункции.ПолучитьСостоянияОбработкиСообщенияПоКоду(РезультатОбработки);
			сшпРаботаСДанными.УстановитьСостояниеСообщения(Идентификатор, СостояниеСообщения, 0, ТекстСообщения);
			
		Иначе
			
			сшпОбщегоНазначения.Ожидание(1);	
			
		КонецЕсли;
		
	КонецЦикла;
	
	ВходящаяОчередьКвитанций.Stop();
	
КонецПроцедуры

//Функция - Отправить транспортное сообщение
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты текущей очереди
//	СтруктураСообщения - структура - структура передаваемого сообщения
//
//Возвращаемое значение:
//	Перечисление.сшпСтатусыСообщений - статус сообщения после обработки
//
Функция ОтправитьТранспортноеСообщение(Очередь, СтруктураСообщения) Экспорт
		
	Попытка
		
		xmlПакет = сшпОбщегоНазначения.СформироватьСообщениеESB_HTTP(ФабрикаXDTO, СтруктураСообщения);
			
	Исключение
		
		ТекстОшибки = "Не удалось сериализовать исходящее сообщение " + СтруктураСообщения.Id + " по причине:"
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());	
		ЗаписьЖурналаРегистрации("Datareon. Обработка очереди исходящих сообщений", УровеньЖурналаРегистрации.Ошибка,,, ТекстОшибки);		
		ЗарегистрироватьОшибку(Очередь, ТекстОшибки);
		
		Возврат Перечисления.сшпСтатусыСообщений.НеВалидно;
		
	КонецПопытки;
	
	Попытка

		ОтправитьСообщение(Очередь, xmlПакет);
		
	Исключение
		
		ТекстОшибки = "Не удалось отправить исходящее сообщение " + СтруктураСообщения.Id + " по причине:"
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());	
		ЗаписьЖурналаРегистрации("Datareon. Обработка очереди исходящих сообщений", УровеньЖурналаРегистрации.Предупреждение,,, ТекстОшибки);
		
		Возврат Перечисления.сшпСтатусыСообщений.ОшибкаОбработки;
		
	КонецПопытки;
	
	Возврат Перечисления.сшпСтатусыСообщений.Отправлено;
	
КонецФункции	

//Процедура - Отправить сообщение
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты
//	xmlПакет - ЗаписьXML - передаваемый пакет
//
Процедура ОтправитьСообщение(Очередь, xmlПакет) Экспорт
	
	Очередь.SendMessage(xmlПакет);
	
КонецПроцедуры	

//Функция - Отправить сообщение об ошибке
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты
//	Класс - Строка - класс сообщения
//	Описание - Строка - тело пакета
//	Свойства - Структура - дополнительные свойства
//
//Возвращаемое значение:
//	Строка - текст ошибки
//
Функция ОтправитьСообщениеОбОшибке(Очередь, Класс, Описание, Свойства) Экспорт
	
	Попытка
		
		Сообщение = сшпОбщегоНазначения.СформироватьСтруктуруПакета("TER", Класс, Описание);
		Сообщение.Properties = Свойства;
		
		xmlПакет = сшпОбщегоНазначения.СформироватьСообщениеESB_HTTP(ФабрикаXDTO, Сообщение);
		
	Исключение
		
		ТекстОшибки = "Не удалось сериализовать сообщение класса TER по причине:"
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());	
		ЗаписьЖурналаРегистрации("Datareon. Обработка очереди исходящих сообщений", УровеньЖурналаРегистрации.Ошибка,,, ТекстОшибки);
		
		ЗарегистрироватьОшибку(Очередь, ТекстОшибки);
		
		Возврат "";
		
	КонецПопытки;
	
	Попытка
		
		ОтправитьСообщение(Очередь, xmlПакет);
		
	Исключение
		
		ТекстОшибки = "Не удалось отправить сообщение класса TER по причине:"
			+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());	
			
		ЗаписьЖурналаРегистрации("Datareon. Обработка очереди сообщений", УровеньЖурналаРегистрации.Предупреждение,,, ТекстОшибки);
		
		Возврат ТекстОшибки;
		
	КонецПопытки;
	
	Возврат "";
	
КонецФункции	

// Функция - Отправить сообщение без очереди
//
// Параметры:
//  Сообщение	 - Структура - Структура описывающая состав отправляемого сообщения.
// 
// Возвращаемое значение:
//  Булево - Признак успешности отправки сообщения на адаптер.
//
Функция ОтправитьСообщениеБезОчереди(Сообщение) Экспорт
	
	ОтправкаРезультат = Истина;
	
	Попытка
		
		ИсходящаяОчередь = сшпКэшируемыеФункции.ПолучитьКомпоненту();
		
		ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
		
		Попытка
			
			ИсходящаяОчередь.InitDataSender(ИдАдаптера + "_datareon_server");
			
		Исключение
			
			ТекстОшибки = "При инициализации транспортного канала для передачи сообщений """ + ИдАдаптера + "_datareon_server" + """ произошла ошибка: " + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ЗаписьЖурналаРегистрации("Datareon. Обработка очереди исходящих сообщений", УровеньЖурналаРегистрации.Ошибка,,, ТекстОшибки);

			Возврат Ложь;
			
		КонецПопытки;

		ОтправитьТранспортноеСообщение(ИсходящаяОчередь, Сообщение);
		
		ИсходящаяОчередь.Stop();
		
	Исключение
		
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ЗаписьЖурналаРегистрации("Datareon. Помещение сообщения в очередь на отправку", УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
		ОтправкаРезультат = Ложь;
	
	КонецПопытки;
	
	Возврат ОтправкаРезультат;

КонецФункции

#КонецОбласти

#Область Логирование

//Процедура Зарегистрировать ошибку
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты
//	Сообщение - Строка - строка сообщения об ошибке
//
Процедура ЗарегистрироватьОшибку(Очередь, Сообщение)
	
	Очередь.WriteLog(3, Сообщение);
	
КонецПроцедуры

//Процедура Зарегистрировать предупреждение
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты
//	Сообщение - Строка - строка сообщения о предупреждении
//
Процедура ЗарегистрироватьПредупреждение(Очередь, Сообщение)
	
	Очередь.WriteLog(2, Сообщение);
	
КонецПроцедуры

//Процедура Зарегистрировать информационное сообщение
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты
//	Сообщение - Строка - строка информационного сообщения
//
Процедура ЗарегистрироватьИнформационноеСообщение(Очередь, Сообщение)
	
	Очередь.WriteLog(1, Сообщение);
	
КонецПроцедуры

//Процедура Зарегистрировать отладочное сообщение
//
//Параметры:
//	Очередь - ВнешняяКомпонента - экземпляр внешней компоненты
//	Сообщение - Строка - строка отладочного сообщения
//
Процедура ЗарегистрироватьОтладочноеСообщение(Очередь, Сообщение)
	
	Очередь.WriteLog(0, Сообщение);
	
КонецПроцедуры

//Процедура - установить соединение и зарегистрировать ошибку
//
//Параметры:
//	Сообщение - Строка - строка сообщения об ошибке
//
Процедура УстановитьСоединениеИЗарегистрироватьОшибку(Сообщение) Экспорт
	
	ИсходящаяОчередь = сшпКэшируемыеФункции.ПолучитьКомпоненту();
	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	ИсходящаяОчередь.InitDataSender(ИдАдаптера + "_datareon_server");
	
	ЗарегистрироватьОшибку(ИсходящаяОчередь, Сообщение);
	
	ИсходящаяОчередь.Stop();
	
КонецПроцедуры

//Процедура - установить соединение и зарегистрировать предупреждение
//
//Параметры:
//	Сообщение - строка - строка сообщения о предупреждении
//
Процедура УстановитьСоединениеИЗарегистрироватьПредупреждение(Сообщение) Экспорт
	
	ИсходящаяОчередь = сшпКэшируемыеФункции.ПолучитьКомпоненту("log");
	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	ИсходящаяОчередь.InitDataSender(ИдАдаптера + "_datareon_server");
	
	ЗарегистрироватьПредупреждение(ИсходящаяОчередь, Сообщение);
	
	ИсходящаяОчередь.Stop();
	
КонецПроцедуры

//Процедура - установить соединение и зарегистрировать информационное сообщение
//
//Параметры:
//	Сообщение - Строка - строка информационного сообщения
//
Процедура УстановитьСоединениеИЗарегистрироватьИнформационноеСообщение(Сообщение) Экспорт
	
	ИсходящаяОчередь = сшпКэшируемыеФункции.ПолучитьКомпоненту("log");
	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	ИсходящаяОчередь.InitDataSender(ИдАдаптера + "_datareon_server");
	
	ЗарегистрироватьИнформационноеСообщение(ИсходящаяОчередь, Сообщение);
	
	ИсходящаяОчередь.Stop();
	
КонецПроцедуры

//Процедура - установить соединение и зарегистрировать отладочное сообщение
//
//Параметры:
//	Сообщение - Строка - строка отладочного сообщения
//
Процедура УстановитьСоединениеИЗарегистрироватьОтладочноеСообщение(Сообщение) Экспорт
	
	ИсходящаяОчередь = сшпКэшируемыеФункции.ПолучитьКомпоненту("log");
	ИдАдаптера = сшпРаботаСКонстантами.ПолучитьИдАдаптера();
	
	ИсходящаяОчередь.InitDataSender(ИдАдаптера + "_datareon_server");
	
	ЗарегистрироватьОтладочноеСообщение(ИсходящаяОчередь, Сообщение);
	
	ИсходящаяОчередь.Stop();
	
КонецПроцедуры

#КонецОбласти

#Область ВспомогательныеМетоды

//Функция - Проверить разрешение на работу
//
//Параметры:
//	ВерсияПараметровПодсистемы - УникальныйИдентификатор - версия параметров подсистемы
//	ТипОчереди - Перечисление.сшпТипыОчередей - тип очереди
//  ИндексПотока - Число - индекс потока
//
//Возвращаемое значение:
//  Булево - результат проверки
//
Функция ПроверитьРазрешениеНаРаботу(ВерсияПараметровПодсистемы, ТипОчереди, ИндексПотока = 0)
		
	Если сшпОбщегоНазначения.ПараметрыПодсистемыОбновлены(ВерсияПараметровПодсистемы) Тогда 
		
		Если Константы.сшпИДАдаптера.Получить() <> сшпРаботаСКонстантами.ПолучитьИдАдаптера() Тогда 
			
			//изменилось имя канала, нужно завершить этот сеанс и начать новый
			Возврат Ложь;
			
		КонецЕсли;
		
		ОбновитьПовторноИспользуемыеЗначения();
		
		Если Не сшпФункциональныеОпции.ИспользоватьСШП() Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
		Если сшпФункциональныеОпции.ТипИспользуемогоКоннектораESB() <> Перечисления.сшпТипыКоннекторовESB.Pipe Тогда 
			
			Возврат Ложь;
			
		КонецЕсли;
		
		Если ТипОчереди <> Перечисления.сшпТипыОчередей.Системная И сшпФункциональныеОпции.ОтключитьПотоки() Тогда 
			
			Возврат Ложь;
			
		КонецЕсли;
		
		Если ТипОчереди = Перечисления.сшпТипыОчередей.Входящая 
			И сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпМаксимальноеКоличествоПотоковОбработкиВходящих") < ИндексПотока Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
		Если ТипОчереди = Перечисления.сшпТипыОчередей.Исходящая  
			И сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпМаксимальноеКоличествоПотоковОбработкиИсходящих") < ИндексПотока Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти